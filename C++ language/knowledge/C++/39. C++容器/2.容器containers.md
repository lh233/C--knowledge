容器用来管理某类对象。为了应付程序中的不同需求，STL 准备了两类共七种基本容器类型：

-   序列式容器（Sequence containers），此为可序群集，其中每个元素均有固定位置—取决于插入时机和地点，和元素值无关。如果你以追加方式对一个群集插入六个元素，它们的排列次序将和插入次序一致。STL提供了三个序列式容器：向量（vector）、双端队列（deque）、列表（list），此外你也可以把 string 和 array 当做一种序列式容器。
-   关联式容器（Associative containers），此为已序群集，元素位置取决于特定的排序准则以及元素值，和插入次序无关。如果你将六个元素置入这样的群集中，它们的位置取决于元素值，和插入次序无关。STL提供了四个关联式容器：集合（set）、多重集合（multiset）、映射（map）和多重映射（multimap）。

示意图如下图所示：

![](https://img2018.cnblogs.com/blog/1075214/201901/1075214-20190111125204355-653568826.png)

## 1.vector

vector（向量）: 是一种序列式容器，事实上和数组差不多，但它比数组更优越。一般来说数组不能动态拓展，因此在程序运行的时候不是浪费内存，就是造成越界。而 vector 正好弥补了这个缺陷，当内存空间不够时，需要重新申请一块足够大的内存并进行内存的拷贝。

**特点**

-   拥有一段连续的内存空间，因此它能非常好的支持随机访问，即 [] 操作符和 .at()，随机访问快。（优点）

-   当向其头部或中间插入或删除元素时，为了保持原本的相对次序，插入或删除点之后的所有元素都必须移动，所以插入或删除的效率比较低。（缺点）

-   在后面插入删除元素最快，此时一般不需要移动内存。（优点）

    

    总结：相当于可拓展的数组（动态数组），随机访问快，在头部和中间插入或删除效率低，但在尾部插入或删除效率高。



**适用场景**

适用于对象简单，变化较小，并且频繁随机访问的场景。



**例子**

以下例子针对整型定义了一个 vector，插入 6 个元素，然后打印所有元素：

```
#include <iostream>
#include <vector>

using namespace std;

int main(int argc, char* argv[])
{
	vector<int> vecTemp;

	for (int i = 0; i<6; i++)
		vecTemp.push_back(i);

	for (int i = 0; i<vecTemp.size(); i++)
		cout << vecTemp[i] <<" "; // 输出：0 1 2 3 4 5

	return 0;
}
```

## 2 deque

deque（double-ended queue）是双向开口的连续内存空间（动态将多个连续空间通过指针数组接合在一起），随时可以增加一段新的空间。deque 的最大任务就是在这些分段的连续空间上，维护其整体连续的假象，并提供随机存取的接口。

### 特点

-   一旦要在 deque 的头部和尾部增加新空间，便配置一段定量连续空间，串在整个 deque 的头部或尾部，因此不论在头部或尾部插入元素都十分迅速。 (优点）
-   在中间部分安插元素则比较费时，因为必须移动其它元素。（缺点）
-   deque 是 list 和 vector 的折中方案。兼有 list 的优点，也有 vector 随机访问效率高的优点。
-   总结：支持随机访问，但效率没有 vector 高，在头部和尾部插入或删除效率高，但在中间插入或删除效率低。



## 适用场景

适用于既要频繁随机访问，又要关心两端数据的插入与删除的场景。

## 例子

以下例子声明了一个浮点类型的 deque，并在容器尾部插入 6 个元素，最后打印出所有元素。

```
#include <iostream>
#include <deque>

using namespace std;

int main(int argc, char* argv[])
{
	deque<float> dequeTemp;

	for (int i = 0; i<6; i++)
		dequeTemp.push_back(i);

	for (int i = 0; i<dequeTemp.size(); i++)
		cout << dequeTemp[i] << " "; // 输出：0 1 2 3 4 5

	return 0;
}
```

## 3. list

List 由双向链表（doubly linked list）实现而成，元素存放在堆中，每个元素都是放在一块内存中。没有空间预留习惯，所以每分配一个元素都会从内存中分配，每删除一个元素都会释放它占用的内存。

## 特点

-   内存空间可以是不连续的，通过指针来进行数据的访问，这个特点使得它的随机存取变得非常没有效率，因此它没有提供 [] 操作符的重载。（缺点）
-   内存空间可以是不连续的，通过指针来进行数据的访问，这个特点使得它的随机存取变得非常没有效率，因此它没有提供 [] 操作符的重载。（缺点）
-   只支持首尾两个元素的直接存取，想获取其他元素（访问时间一样），则需要遍历链表。（缺点）
-   总结：不支持随机访问，在任意位置的插入和删除效率都较高。



## 适用场景

适用于经常进行插入和删除操作并且不经常随机访问的场景。

## 例子

以下例子产生一个空 list，准备放置字符，然后将 'a' 至 'z' 的所有字符插入其中，利用循环每次打印并移除集合的第一个元素，从而打印出所有元素：

```
#include <iostream>
#include <list>

using namespace std;

int main(int argc, char* argv[])
{
	list<char> listTemp;

	for (char c = 'a'; c <= 'z'; ++c)
		listTemp.push_back(c);

	while (!listTemp.empty())
	{
		cout <<listTemp.front() << " ";
		listTemp.pop_front();
	}

	return 0;
}
```

成员函数empty()的返回值告诉我们容器中是否还有元素，只要这个函数返回 false，循环就继续进行。循环之内，成员函数front()会返回第一个元素，pop_front()函数会删除第一个元素。

注意：list<指针> 完全是性能最低的做法，还不如直接使用 list<对象> 或使用 vector<指针> 好，因为指针没有构造与析构，也不占用很大内存。

# 4 set

set（集合）顾名思义，就是数学上的集合——每个元素最多只出现一次，并且 set 中的元素已经从小到大排好序。
