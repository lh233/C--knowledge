容器用来管理某类对象。为了应付程序中的不同需求，STL 准备了两类共七种基本容器类型：

-   序列式容器（Sequence containers），此为可序群集，其中每个元素均有固定位置—取决于插入时机和地点，和元素值无关。如果你以追加方式对一个群集插入六个元素，它们的排列次序将和插入次序一致。STL提供了三个序列式容器：向量（vector）、双端队列（deque）、列表（list），此外你也可以把 string 和 array 当做一种序列式容器。
-   关联式容器（Associative containers），此为已序群集，元素位置取决于特定的排序准则以及元素值，和插入次序无关。如果你将六个元素置入这样的群集中，它们的位置取决于元素值，和插入次序无关。STL提供了四个关联式容器：集合（set）、多重集合（multiset）、映射（map）和多重映射（multimap）。

示意图如下图所示：

![](https://img2018.cnblogs.com/blog/1075214/201901/1075214-20190111125204355-653568826.png)

## 1.vector

vector（向量）: 是一种序列式容器，事实上和数组差不多，但它比数组更优越。一般来说数组不能动态拓展，因此在程序运行的时候不是浪费内存，就是造成越界。而 vector 正好弥补了这个缺陷，当内存空间不够时，需要重新申请一块足够大的内存并进行内存的拷贝。

**特点**

-   拥有一段连续的内存空间，因此它能非常好的支持随机访问，即 [] 操作符和 .at()，随机访问快。（优点）

-   当向其头部或中间插入或删除元素时，为了保持原本的相对次序，插入或删除点之后的所有元素都必须移动，所以插入或删除的效率比较低。（缺点）

-   在后面插入删除元素最快，此时一般不需要移动内存。（优点）

    

    总结：相当于可拓展的数组（动态数组），随机访问快，在头部和中间插入或删除效率低，但在尾部插入或删除效率高。



**适用场景**

适用于对象简单，变化较小，并且频繁随机访问的场景。



**例子**

以下例子针对整型定义了一个 vector，插入 6 个元素，然后打印所有元素：

```
#include <iostream>
#include <vector>

using namespace std;

int main(int argc, char* argv[])
{
	vector<int> vecTemp;

	for (int i = 0; i<6; i++)
		vecTemp.push_back(i);

	for (int i = 0; i<vecTemp.size(); i++)
		cout << vecTemp[i] <<" "; // 输出：0 1 2 3 4 5

	return 0;
}
```

