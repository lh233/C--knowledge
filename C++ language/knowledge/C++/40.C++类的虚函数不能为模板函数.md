C++类中的虚函数不能为模板函数

首先，理解模板的原理。例如，定义了一个模板函数：

> template<typename A>
> void Func(const A& a) {undefined
>    std::cout <<"Func(const A& a) : "<< a << std::endl;
> }

编译器在编译期间，会检查代码中哪些地方使用了这个函数，例如，如果在整个程序中使用到了两种类型：Func<int>(9);

Func<float>(9.3); 则编译器会生成两份函数的二进制代码：void Func(const int& a),以及void Func(const float& a)。

 

由于对于类的虚函数来说，其是否被调用是在程序运行的时候才知道，因此编译阶段不知道需要生成几份函数。    例如，基类是Base，有两个子类A和B, 代码中使用基类的指针来调用子类的虚函数 ，在编译阶段并不能知道调用的是哪个子类的虚函数，因此，编译器不知道类A和B中的模板函数被调用的情况，因此，不知道需要生成几份函数。

另外，每个含有虚函数的类中都有一个虚函数表，该虚函数表存储着该类的所有的虚函数的地址，因此，虚函数为模板函数时，该表的大小是不知道的，因此编译器禁止！

但是，类的普通的成员函数是可以为模板函数的！

